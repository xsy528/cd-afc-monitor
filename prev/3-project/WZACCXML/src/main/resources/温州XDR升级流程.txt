升级流程：

1. 更新XDR工程，保证代码是最新的。

2. 根据最新的.x文件升级自定义XML文件wz*.*.*.xml，升级方式大致有两种：
(a) 根据原始的.x文件新旧版本比对，根据差异修改新版XML文件。
(b) 通过AFCXdrGenerator项目已.x文件生成原始的XML文件，然后比对新旧版本的XML，根据差异修改新版XML文件。
(第二种方法如果原始.x文件注释等有问题的话，生成的XML文件可能会少东西)。

3. 运行AFCXdrGenerator项目的XDRWindow(运行前检查TemplateConfig.xml是否本地被修改过)。

4. 在菜单"工具菜单"中选择"打开XML描述文件"，选择新版的wz*.*.*.xml。

5. 检查升级过的wz*.*.*.xml结构有无问题。(比如跟节点中有无很独立的结构体)

6. 勾选全部的项目，然后在菜单"工具菜单"中选择"生成Decoder，Encoder"，路径选择为WZACCXML工程的src目录。

7. 生成完成后，界面会提示成功。

8. 刷新WZACCXML工程，如果升级正确的话，项目不会报编译异常(只有IXDRDecoder，IXDRDecoder新增接口会有编译异常)，如果有编译异常，通常是wz*.*.*.xml没有升级正确，需要检查wz*.*.*.xml。

9.先整理WZACCXML工程的Organize Import的，把自动代码生成中的无用的类Import自动删除，在整个工程Format下，确保和SVN上的Format一致。

10.如果IXDRDecoder，IXDRDecoder新增接口，则增加实现。

11.还原那些手动修改过的类：
(a) 通信模块：Packet_t,ESPack_t,Mack_Ans_t,EventUpload_Req_t,TaskReport_Req_t(private TaskAttribute_t TaskAttribute = new TaskAttribute_t();原代码没有实例化TaskAttribute)需要还原。
如果规范中有新增字段，需要比对还原。

12.表结构重新生成：
(a) 参数表(如果本次升级没有参数的修改，则可以跳过)：因为参数是对下的，所以每次版本升级需要重新生成表，目前升级会删除原来表的数据，步骤如下：
          如果是上线版本修改则人工修改库表结构，否则原来的参数数据全部被删除。(也可以先删除再通过文件导入)
    <1> 在XDRWindow程序打开的wz*.*.*.xml结构中，在XDR结构跟节点选择"EodFile_t"下面的"EODParameter"节点下面的所有参数组件跟节点。
    <2> 菜单"工具菜单"中选择"生成HibernateMapping"，会生成<mapping class="****" />之类的Mapping信息。
    <3> 拷贝这些mapping信息到AFCDailyHandle下面example目录下的/hibernate.oracle.cfg.xml，覆盖掉原来的Mapping信息。
    <4> 检查/hibernate.oracle.cfg.xml文件中的connection.username是xdr_db用户，修改test/res目录下的log4j.properties中的log4j.logger.org.hibernate=DEBUG(可以显示Hibernate的SQL语句生成)。
    <5> 调用TableGenerator类,需要注意指定的cfg.xml文件为hibernate.oracle.cfg.xml，重新生成表结构，序列。
    <6> 控制台上拷贝Hibernate打印的SQL语句，到AFCXdrGenerator工程example目录下的HIBERNATE_EOD.sql文件中。
    <7> 修改FormatHibernateSQlLog类中的数据库类型为"ORACLE",然后执行。
    <8> 拷贝控制台中已经整理过的SQL语句在xdr_db数据库中执行。
    <9> 执行温州XDR工程中的TestEODEntityToDB测试类(需要注意spring-datasource.xml里面的数据库用户为xdr_db)，如果测试通过，则EOD参数升级基本没事。
    <10>把整理过的SQL语句在ACC,AFC数据库执行.(包括ACC,LC,SC数据库)
    <11>保留整理过的SQL语句为文件发送DBA，供版本升级使用。
    
(b) 交易明细表(交易表其实是自己使用，如果是版本升级，结构调整不大的话，可以选择不升级，因为交易表升级涉及到数据处理的代码，很多存储过程修改，推荐为上线版本时再统一升级)
    ACC级交易明细表分一票通、一卡通，而且再分运营日、结算日，且分365天表，需要注意，表结构是合并所有一票通(或一卡通)的所有交易类型的并集，模板表也是通过Hibernate生成，步骤如下:
    <1> 根据新版的tianjinACC*.*.*.xml生成新的YptTransDetail，YktTransDetail类。 
    <2> 利用Hibernate生成新的交易明细表,此时表为模板表：TYPT_TRANS_DETAIL_BUSI,TYKT_TRANS_DETAIL_BUSI,TYPT_TRANS_DETAIL_SETT,TYKT_TRANS_DETAIL_SETT.
    <3> 对于TYPT_TRANS_DETAIL_SETT,TYKT_TRANS_DETAIL_SETT需要手动添加SETTDAY字段。
    <4> 根据SVN上的文档[表需求(交易明细).xls]添加自定义的列到TYPT_TRANS_DETAIL_BUSI,TYKT_TRANS_DETAIL_BUSI,TYPT_TRANS_DETAIL_SETT,TYKT_TRANS_DETAIL_SETT。
	<5> 为TYPT_TRANS_DETAIL_BUSI,TYKT_TRANS_DETAIL_BUSI,TYPT_TRANS_DETAIL_SETT,TYKT_TRANS_DETAIL_SETT添加唯一性约束：TRANSACTIONDATETIME, DEVICEID, UDSN
    <6> 以TYPT_TRANS_DETAIL_BUSI,TYKT_TRANS_DETAIL_BUSI,TYPT_TRANS_DETAIL_SETT,TYKT_TRANS_DETAIL_SETT为模板重新生成365天表。
    <7> 对于重新生成的交易明细表结构在软件版本升级时重新生成下。(上线后版本的更新需要换一种方式更新，不能按照这种更新方式)
    <8> 以TYPT_TRANS_DETAIL_BUSI表为模板，重新创建TYPT_TRANS_DETAIL_ERROR表，再加上SETTDAY列，然后根据SVN上的文档[表需求(交易明细).xls]添加自定义的列TYPT_TRANS_DETAIL_ERROR(需要注意这种表不需要加唯一约束)。
    <9> 以TYKT_TRANS_DETAIL_BUSI表为模板，重新创建TYKT_TRANS_DETAIL_ERROR表，再加上SETTDAY列，然后根据SVN上的文档[表需求(交易明细).xls]添加自定义的列TYKT_TRANS_DETAIL_ERROR(需要注意这种表不需要加唯一约束)。
          
    
    AFC级交易明细表分一票通、一卡通，且分365天表，需要注意，表结构是合并所有一票通(或一卡通)的所有交易类型的并集，模板表也是通过Hibernate生成，步骤如下:
    <1> 根据新版的wz*.*.*.xml生成新的YptTransDetail，YktTransDetail类。 
    <2> 利用Hibernate生成新的交易明细表,此时表为模板表：TYPT_TRANS_DETAIL,TYKT_TRANS_DETAIL.
    <3> 根据SVN上的文档[表需求(交易明细).xls]添加自定义的列到TYPT_TRANS_DETAIL,TYKT_TRANS_DETAIL。
	<4> 为TYPT_TRANS_DETAIL,TYKT_TRANS_DETAIL添加唯一性约束：TRANSACTIONDATETIME, DEVICEID, UDSN
    <5> 以TYPT_TRANS_DETAIL,TYKT_TRANS_DETAIL为模板重新生成365天表。
    <6> 对于重新生成的交易明细表结构在软件版本升级时重新生成下。(上线后版本的更新需要换一种方式更新，不能按照这种更新方式)
    <7> 以TYPT_TRANS_DETAIL表为模板，重新创建TYPT_TRANS_DETAIL_ERROR表，然后根据SVN上的文档[表需求(交易明细).xls]添加自定义的列TYPT_TRANS_DETAIL_ERROR(需要注意这种表不需要加唯一约束)。
    <8> 以TYKT_TRANS_DETAIL表为模板，重新创建TYKT_TRANS_DETAIL_ERROR表，然后根据SVN上的文档[表需求(交易明细).xls]添加自定义的列TYKT_TRANS_DETAIL_ERROR(需要注意这种表不需要加唯一约束)。

(c) AR表
          温州的AR表有很多，是整理过的横向结构：每一类设备的AR有2张表，数据处理时一个XDR结构对应表1的多条记录和表2的一条记录。
    步骤：
    <1>运行AutoUtil.java，作用是把需要用到的xdr结构里的字段分别写到各自.text文件里，方便合成表时copy。
    <2>ARComm_t和SLEDataFileHeader_t和*shotInfo_t里的字段合成一张表
       ARComm_t和SLEDataFileHeader_t和*FareInfo_t里的字段合成一张表
                   注意添加recordID和序列 
                               
    <3>利用Hibernate生成表结构。注意有不少字段过长，需要打标签指定字段名
        
 13.代码修改。
(a) 参数部分：如果新版wz*.*.*.xml结构中参数部分添加了结构，则需要在通信前置机、工作台的HibernateMapping文件中重新覆盖mapping class信息 。
(b) 交易部分修改程序代码(这块其实量比较大，很多SQL可能要重新，很多存储过程要重新修改编译，所以对于交易表修改不要轻易修改)。
           
 14.提交温州XDR工程修改后的代码。
 

    
    